---
title: "Week 6: Visualizing Uncertainty"
author: "Emorie D Beck"
format: 
  revealjs:
    incremental: true
    code-tools: true
    code-copy: true
    code-line-numbers: true
    code-link: true
    preview-links: true
    slide-number: true
    self-contained: true
    fig-height: 4
    fig-width: 6
    fig-align: center
    css: custom.css
    theme: psc290
    # highlight-style: tango
    margin-left: "0"
    margin-right: "0"
    width: 1400
    # height: 900
    footer: "PSC 290 - Data Visualization"
    logo: "https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"
  # pptx: 
  #   incremental: true  
  #   # code-tools: true
  #   # code-copy: true
  #   # code-line-numbers: true
  #   # code-link: true
  #   css: custom.css
  #   theme: psc290
  #   highlight-style: atom-one-dark
  #   footer: "PSC 290 - Data Visualization"
  #   logo: "https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"
editor_options: 
  chunk_output_type: console
---

```{r, echo = F}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, error = F, out.width = "90%", fig.align="center")
options(knitr.kable.NA = '')
```

# Visualizing Uncertainty  

## Packages  

```{r, echo = T}
#| code-line-numbers: "6,10,11,12,13,14"
library(RColorBrewer)
library(knitr)
library(kableExtra)
library(plyr)
library(broom)
library(modelr)
library(lme4)
library(broom.mixed)
library(tidyverse)
library(ungeviz)
library(ggdist)
library(tidybayes)
library(distributional)
library(gganimate)
```

## Visualizing Uncertainty  
* Why is visualizing uncertainty important?  
  + Point estimates are over-emphasized and interval estimates are unemphasized (or ignored)
  + Most people <font color="red">*misperceive*</font> both (1) common uncertainty visualizations and (2) most common uncertainty metrics 
  + In other words, people make errors about error
  + Probability is hard, and most aren't taught about probability distributions (and more)  

## Theories of Visualizing Uncertainty  

Why do people misperceive uncertainty, and how can we mitigate it? 

::::{.fragment}

```{r, echo = F, fig.align='center', out.width="70%"}
knitr::include_graphics("https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/06-week6-uncertainty/02-images/uncert-theories.png")
```

::::

## Quick Side Note: Custom Themes {.smaller}

* We have a lot to cover today, so I'm going to skip over some of the usual "how to start with the basics and make it aesthetically pleasing" 
* Instead, we'll create a custom these that captures some of our usual additions  
* This will save us both time and text!  
* I highly recommend doing this in your own work  

::::{.fragment}

```{r}
my_theme <- function(){
  theme_classic() + 
  theme(
    legend.position = "bottom"
    , legend.title = element_text(face = "bold", size = rel(1))
    , legend.text = element_text(face = "italic", size = rel(1))
    , axis.text = element_text(face = "bold", size = rel(1.1), color = "black")
    , axis.title = element_text(face = "bold", size = rel(1.2))
    , plot.title = element_text(face = "bold", size = rel(1.2), hjust = .5)
    , plot.subtitle = element_text(face = "italic", size = rel(1.2), hjust = .5)
    , strip.text = element_text(face = "bold", size = rel(1.1), color = "white")
    , strip.background = element_rect(fill = "black")
    )
}
```

::::

## Error Bars {.smaller}

* First, let's examine the usual ways that we show uncertainty around point estimates (e.g., means, model parameter estimates, etc.) using interval estimates (+/- 1 SE/D, confidence interval)  

::::{.fragment}

```{r, echo=F}
load(url("https://github.com/emoriebeck/psc290-data-viz-2022/blob/main/05-week5-time-series/01-data/gsoep.RData?raw=true"))
gsoep
```

::::

## Error Bars  {.smaller}

:::{.nonincremental}  
* First, let's examine the usual ways that we show uncertainty around point estimates (e.g., means, model parameter estimates, etc.) using interval estimates (+/- 1 SE/D, confidence interval)  
:::  

::::{.fragment}
::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|3-4|1,5|6-8|9-10|11-18"
pomp <- function(x) (x - min(x, na.rm = T))/(max(x, na.rm = T) - min(x, na.rm = T))*10
gsoep_desc <- gsoep %>%
  filter(year == 2005 & age < 30) %>%
  filter(SID %in% sample(unique(.$SID), 500)) %>%
  mutate(SRhealth = pomp(SRhealth)) %>%
  group_by(SID, age) %>%
  mutate(health = rowMeans(cbind(SRhealth, satHealth), na.rm = T)) %>%
  ungroup() %>%
  select(SID, age, health) %>%
  drop_na() %>%
  mutate(
    mean = mean(health)
    , sd = sd(health)
    , se = sd/sqrt(n())
    , ci99 = se*2.576
    , ci95 = se*1.96
    , ci80 = se*1.282
    )
gsoep_desc
```

:::
:::{.column}

```{r, echo = F}
pomp <- function(x) (x - min(x, na.rm = T))/(max(x, na.rm = T) - min(x, na.rm = T))*10
gsoep_desc <- gsoep %>%
  filter(year == 2005 & age < 30) %>%
  filter(SID %in% sample(unique(.$SID), 500)) %>%
  mutate(SRhealth = pomp(SRhealth)) %>%
  group_by(SID, age) %>%
  mutate(health = rowMeans(cbind(SRhealth, satHealth), na.rm = T)) %>%
  ungroup() %>%
  select(SID, age, health) %>%
  drop_na() %>%
  mutate(
    mean = mean(health)
    , sd = sd(health)
    , se = sd/sqrt(n())
    , ci99 = se*2.576
    , ci95 = se*1.96
    , ci80 = se*1.282
    )
gsoep_desc
```

:::
::::
::::

## Error Bars  {.smaller}

:::{.nonincremental}
* First, let's examine the usual ways that we show uncertainty around point estimates (e.g., means, model parameter estimates, etc.) using interval estimates (+/- 1 SE/D, confidence interval)  
:::
* But we need to reshape the data to allow us to actually plot them:  

::::{.fragment}
::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|2|3-7|8-9|10-11"
gsoep_desc <- gsoep_desc %>% 
  select(mean:ci80, health, SID) %>%
  pivot_longer(
    cols = c(-mean, -SID)
    , names_to = "measure"
    , values_to = "value"
    ) %>%
  mutate(SID = ifelse(measure == "health" | row_number() %in% 1:5, SID, NA)) %>%
  drop_na() %>%
  mutate(measure2 = factor(measure, rev(c("health", "sd", "se", "ci99", "ci95", "ci80")))
         , measure = as.numeric(mapvalues(measure, c("health", "sd", "se", "ci99", "ci95", "ci80"), 6:1)))
gsoep_desc
```

:::
:::{.column}

```{r, echo = F}
gsoep_desc <- gsoep_desc %>% 
  select(mean:ci80, health, SID) %>%
  pivot_longer(
    cols = c(-mean, -SID)
    , names_to = "measure"
    , values_to = "value"
    ) %>%
  mutate(SID = ifelse(measure == "health" | row_number() %in% 1:5, SID, NA)) %>%
  drop_na() %>%
  mutate(measure2 = factor(measure, rev(c("health", "sd", "se", "ci99", "ci95", "ci80")))
         , measure = as.numeric(mapvalues(measure, c("health", "sd", "se", "ci99", "ci95", "ci80"), 6:1)))
gsoep_desc
```

:::
::::
::::

## Error Bars  {.smaller}

```{r, fig.dim=c(10,3), fig.align='center', echo = F}
gsoep_desc %>%
  ggplot(aes(y = measure, x = mean)) +
    geom_point(size = 3, color = "darkorange3") + 
    geom_jitter(data = gsoep_desc %>% filter(measure == 6), aes(x = value), alpha = .7, height = .3, width = 0, color = "grey") + 
    geom_errorbar(data =  gsoep_desc %>% filter(measure != 6), aes(xmin = mean - value, xmax = mean + value), width = .1) + 
    scale_y_continuous(limits = c(1,6.8), breaks = 1:6, labels = rev(c("Raw", "SD", "SE", "99% CI", "95% CI", "80% CI"))) + 
    scale_x_continuous(limits = c(0,10), breaks = 0:10) + 
    annotate("segment", x = 9, xend = gsoep_desc$mean[1]+.15, y = 6.7, yend = 6.05, colour = "darkorange3", size = 1.5, arrow = arrow()) + 
    annotate("label", label = "mean", y = 6.75, x = 9, fill = "darkorange3", color = "white") + 
    labs(x = "Health (0-10)", y = NULL) + 
    geom_point(shape = 21, size = 3, fill = "darkorange3", color = "grey90") + 
    my_theme()
```

## So What Do We Do?  

* Lots of things, not all of which we have time for today. See also:
  + [https://janhove.github.io/visualise_uncertainty/](https://janhove.github.io/visualise_uncertainty/)
  + [https://wilkelab.org/SDS375/slides/visualizing-uncertainty.html#1](https://wilkelab.org/SDS375/slides/visualizing-uncertainty.html#1)
  + [https://wilkelab.org/ungeviz/](https://wilkelab.org/ungeviz/)
  + #TeamBayes: [http://mjskay.github.io/tidybayes/](http://mjskay.github.io/tidybayes/)
  + #TeamFrequentist: [https://mjskay.github.io/ggdist/](https://mjskay.github.io/ggdist/)

## Outline for Today: 

* Proportions / Probability  
  + icon array
* Point Estimates
  + half-eye
  + gradient interval
  + quantile dotplot
  + raincloud
* Animated (sometimes)
  + hypothetical outcome plots
  + ensemble display
  
# Proportions / Probability  

## Proportions / Probability  {.smaller}
* We already covered proportions and probability, but this one deserves being highlighted itself
* How much of our sample was unmarried? 

::::{.fragment}

```{r}
#| code-line-numbers: "|2|3|4-7"
gsoep %>%
  filter(year == 2012 & !is.na(marital)) %>%
  mutate(marital = ifelse(marital == 4, "Never Married", "Married")) %>%
  group_by(marital) %>%
  tally() %>%
  ungroup() %>%
  mutate(prop = round(n/sum(n)*100))
```

::::

## Proportions / Probability  {.smaller}

:::{.nonincremental}
* We already covered proportions and probability, but this one deserves being highlighted itself
* How much of our sample was unmarried? 
:::
* We have to trick `ggplot2` into making this figure with a grid

::::{.fragment}

```{r}
#| code-line-numbers: "|2|3-4"
tibble(
  value = c(rep(1, 76), rep(2,24))
  , x = rep(1:10, each = 10)
  , y = rep(1:10, times = 10)
  ) 
```

::::

## Proportions / Probability  {.smaller}

:::{.nonincremental}
* We already covered proportions and probability, but this one deserves being highlighted itself
* How much of our sample was unmarried? 
:::

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "6-9"
tibble(
  value = c(rep(1, 76), rep(2,24))
  , y = rep(1:10, each = 10)
  , x = rep(1:10, times = 10)
  ) %>%
  ggplot(aes(x = x, y = y, color = factor(value))) +
    geom_point(shape = "square", size = 5) + 
    theme_void() + 
    theme(legend.position = "none")
```

:::
:::{.column}

```{r, echo = F}
tibble(
  value = c(rep(1, 76), rep(2,24))
  , y = rep(1:10, each = 10)
  , x = rep(1:10, times = 10)
  ) %>%
  ggplot(aes(x = x, y = y, color = factor(value))) +
    geom_point(shape = "square", size = 5) + 
    theme_void() + 
    theme(legend.position = "none")
```

:::
::::

## Proportions / Probability  {.smaller}

:::{.nonincremental}
* We already covered proportions and probability, but this one deserves being highlighted itself
* How much of our sample was unmarried? 
:::

::::{.columns}
:::{.column}

```{r, eval = F, fig.dim=c(4,4.2), out.width="80%"}
#| code-line-numbers: "7-9,12"
tibble(
  value = c(rep(1, 76), rep(2,24))
  , y = rep(1:10, each = 10)
  , x = rep(1:10, times = 10)
  ) %>%
  ggplot(aes(x = x, y = y, color = factor(value))) +
    geom_point(shape = "square", size = 8) + 
    scale_color_manual(values = c("lightgrey", "darkblue")) + 
    labs(title = "24% Remained Unmarried in 2012") + 
    theme_void() + 
    theme(legend.position = "none"
          , plot.title = element_text(hjust = .5, face = "bold"))
```

:::
:::{.column}

```{r, echo = F, fig.dim=c(4,4.2), out.width="70%"}
tibble(
  value = c(rep(1, 76), rep(2,24))
  , y = rep(1:10, each = 10)
  , x = rep(1:10, times = 10)
  ) %>%
  ggplot(aes(x = x, y = y, color = factor(value))) +
    geom_point(shape = "square", size = 8) + 
    scale_color_manual(values = c("lightgrey", "darkblue")) + 
    labs(title = "24% Remained Unmarried in 2012") + 
    theme_void() + 
    theme(legend.position = "none"
          , plot.title = element_text(hjust = .5, face = "bold"))
```

:::
::::

# Point Estimates  

## Point Estimates  {.smaller}

* Most often, we want to visualize either point esimates or other visualizations of models
* We touched on this a couple of weeks ago when we talked about `broom` and `broom.mixed`
* I mentioned then that one of the challenges comes from where the interval estimate comes from, which includes:
  + (Frequentist) Standard Errors
  + (Frequentist) Confidence Intervals
  + Bootstrapped / Profile Confidence Intervals
  + Prediction Intervals
  + (Bayesian) Credible Intervals
  + (Bayesian) Posterior Distributions
* I'll stay out of Bayes for now :(

## Point Estimates  {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "2|3|4-8|9-14|15"
gsoep_ex <- gsoep %>%
  filter(year == "2000") %>%
  select(SID, age, marital, gender) %>%
  inner_join(
    gsoep %>%
      filter(year == "2015") %>%
      select(SID, SRhealth)
  ) %>%
  mutate(marital = factor(
    marital
    , 1:4
    , c("Married", "Separated", "Widowed", "Never Married")
    ), age = age/10
    , gender = factor(gender, c(1,2), c("Male", "Female"))) %>%
  drop_na()
gsoep_ex
```

:::
:::{.column}

```{r, echo = F}
gsoep_ex <- gsoep %>%
  filter(year == "2000") %>%
  select(SID, age, marital, gender) %>%
  inner_join(
    gsoep %>%
      filter(year == "2015") %>%
      select(SID, SRhealth)
  ) %>%
  mutate(marital = factor(
    marital
    , 1:4
    , c("Married", "Separated", "Widowed", "Never Married")
    ), age = age/10
    , gender = factor(gender, c(1,2), c("Male", "Female"))) %>%
  drop_na()
gsoep_ex
```

:::
::::

## Point Estimates From Model Predictions  

```{r, echo = F, fig.dim=c(12, 6), fig.align='center'}
m1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)
tidy1 <- tidy(m1)

p1 <- tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error)), 
        scale = .5
    ) +
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_halfeye()"
    ) + 
  my_theme()

p2 <-tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_gradientinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , scale = .75
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_gradientinterval()"
    ) + 
  my_theme()

p3 <-tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_dotsinterval()"
    ) + 
  my_theme()

p4 <-tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
    ) + 
  labs(
    x = "Parameter Estimates()"
    , y = NULL
    , title = "stat_dots()"
    ) + 
  my_theme()

p5 <-tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , side = "bottomleft", layout = "swarm"
    ) + 
    stat_histinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_halfeye() + stat_dots()"
    ) + 
  my_theme()

p6 <-tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_eye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_eye()"
    ) + 
  my_theme()

cowplot::plot_grid(p1, p2, p3, p6, p5, p4, nrow = 2)
```

## Marginal Means from Model Predictions  

```{r, echo = F, fig.dim=c(12, 6), fig.align='center'}
m1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)
tidy1 <- tidy(m1)

p1 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
        scale = .5
    ) +
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_halfeye()"
    ) + 
  my_theme()

p2 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_gradientinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
      , scale = .75
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_gradientinterval()"
    ) + 
  my_theme()

p3 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
      , quantiles = 50
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_dotsinterval()"
    ) + 
  my_theme()

p4 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
      , quantiles = 50
    ) + 
  labs(
    x = "Parameter Estimates()"
    , y = NULL
    , title = "stat_dots()"
    ) + 
  my_theme()

p5 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
      , side = "bottomleft", layout = "swarm"
    ) + 
    stat_histinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_halfeye() + stat_dots()"
    ) + 
  my_theme()

p6 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_eye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))
    ) + 
  labs(
    x = "Parameter Estimates"
    , y = NULL
    , title = "stat_eye()"
    ) + 
  my_theme()

cowplot::plot_grid(p1, p2, p3, p6, p5, p4, nrow = 2)
```

## Point Estimates and Marginal Means  

* `stat_halfeye()`: Visual Boundaries
* `stat_eye()`: Visual Boundaries
* `stat_gradientinterval()`: Visual Semiotics
* `stat_dots()`: Frequency Framing
* `stat_dotsinterval()`: Frequency Framing
* `stat_halfeye()`+ `stat_dots()`: Visual Boundaries + Frequency Framing

## Point Estimates and Marginal Means  {.smaller}
### Core syntax  
* The benefit of ggdist is that it allows you to use essentially identical syntax to produce lots of different kinds of plots  
* All we have to do is swap out the `geom`

:::: {.fragment}
::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|1-2|4-10|5|6|7-9"
m1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)
tidy1 <- tidy(m1)

tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
    ) +
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
m1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)
tidy1 <- tidy(m1)

tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
    ) +
  my_theme()
```

:::
::::

::::

## `stat_halfeye()` {.smaller}

We can pull the predictions from model terms or marginal means  

::::{.columns}
:::{.column}
::::{.fragment}

Model Terms:

```{r}
#| code-line-numbers: "4-6"
tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
    ) +
  my_theme()
```

::::
:::
:::{.column}
::::{.fragment}

Marginal Means: 

```{r}
#| code-line-numbers: "|1-2|3|4|5-8|7"
gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
    stat_halfeye(
        aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
    ) +
  my_theme()
```

::::
:::
::::

## Point Estimates and Marginal Means  {.smaller}
### Core syntax  

Let's do a little hack and create our whole plots **except** the `geom`, so that we can build them with less syntax: 

::::{.columns}
:::{.column}

```{r}
p1 <- tidy1 %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(y = term)) + 
  geom_vline(aes(xintercept = 0), linetype = "dashed") + 
  labs(
    x = "Parameter Estimate"
    , y = NULL
    , title = "Model Estimates"
    , caption = "Outcome: Self-Rated Health"
    ) +
  my_theme()
```

:::
:::{.column}

```{r}
p2 <- gsoep_ex %>%
  data_grid(marital) %>%
  mutate(age = mean(gsoep_ex$age)) %>%
  augment(m1, newdata = ., se_fit = T) %>%
  ggplot(aes(y = marital)) + 
  labs(
    x = "Model Predicted Self-Rated Health"
    , title = "Marginal Means"
    , y = NULL
    ) +
  my_theme()
```

:::
::::

## `stat_halfeye()` {.smaller}  

We can pull the predictions from model terms or marginal means  

::::{.columns}
:::{.column}
::::{.fragment}

Model Terms:

```{r}
#| code-line-numbers: "2"
p1 +
  stat_halfeye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
  ) + 
  labs(subtitle = "stat_halfeye()")
```

::::
:::
:::{.column}
::::{.fragment}

Marginal Means: 

```{r}
#| code-line-numbers: "2"
p2 + 
  stat_halfeye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
  ) + 
  labs(subtitle = "stat_halfeye()")
```

::::
:::
::::

## `stat_eye()` {.smaller}  

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2"
p1 +
  stat_eye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
  ) + 
  labs(subtitle = "stat_eye()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2"
p2 + 
  stat_eye(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
  ) + 
  labs(subtitle = "stat_eye()")
```

:::
::::

## `stat_gradientinterval()` {.smaller}  

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2"
p1 +
  stat_gradientinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
  ) + 
  labs(subtitle = "stat_gradientinterval()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2"
p2 + 
  stat_gradientinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
  ) + 
  labs(subtitle = "stat_gradientinterval()")
```

:::
::::

## `stat_dots()` {.smaller}  

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2"
p1 +
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), 
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
::::

## `stat_dots()` {.smaller}  
You can also change the number of dots: 

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2,4"
p1 +
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2,4"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
::::

## `stat_dots()` {.smaller}  
There are also three different layouts

::::{.columns}
:::{.column width="33%"}

`layout = "bin"`:

```{r}
#| code-line-numbers: "2,4-5"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
      , layout = "bin"
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
:::{.column width="33%"}

`layout = "weave"`:

```{r}
#| code-line-numbers: "2,4-5"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
      , layout = "weave"
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
:::{.column width="33%"}

`layout = "swarm"`:

```{r}
#| code-line-numbers: "2,4-5"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
      , layout = "swarm"
  ) + 
  labs(subtitle = "stat_dots()")
```

:::
::::

## `stat_dotsinterval()` {.smaller}

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2,4"
p1 +
  stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
  ) + 
  labs(subtitle = "stat_dotsinterval()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2,4"
p2 + 
  stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
  ) + 
  labs(subtitle = "stat_dotsinterval()")
```

:::
::::

## `stat_dotsinterval()` {.smaller}

You can apply many of the same arguments as "regular" `stat_dots()`

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "2,4[5"
p1 +
  stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
      , layout = "swarm"
  ) + 
  labs(subtitle = "stat_dotsinterval()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "2,4-5"
p2 + 
  stat_dotsinterval(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
      , layout = "swarm"
  ) + 
  labs(subtitle = "stat_dotsinterval()")
```

:::
::::

## `stat_halfeye()`+ `stat_dots()` {.smaller}

::::{.columns}
:::{.column}

Model Terms:

```{r}
#| code-line-numbers: "|2,4-6|8"
p1 +
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
      , quantiles = 50
      , side = "bottomleft"
      , layout = "swarm"
  ) + 
  stat_halfeye(
    aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))
  ) + 
  labs(subtitle = "`stat_halfeye()`+ `stat_dots()")
```

:::
:::{.column}

Marginal Means: 

```{r}
#| code-line-numbers: "|2,4-6|8"
p2 + 
  stat_dots(
      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
      , quantiles = 50
      , side = "bottomleft"
      , layout = "swarm"
  ) + 
  stat_halfeye(
    aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) 
  ) + 
  labs(subtitle = "`stat_halfeye()`+ `stat_dots()")
```

:::
::::

## Simple Slopes  {.smaller}

Let's say we want to know if married and unmarried people differ in their self-rated health as a function of their age:

::::{.columns}
:::{.column}

```{r, eval=T}
gsoep_ex2 <- gsoep_ex %>%
  filter(marital %in% c("Married", "Never Married"))
gsoep_ex2
```

:::
:::{.column}

```{r, echo=T}
m2 <- lm(SRhealth ~ age + marital + age:marital, data = gsoep_ex2)
tidy(m2)
```

:::
::::

## Simple Slopes  {.smaller}

We can plot this using an extension of `geom_ribbon()`, `stat_lineribbon()`  

::::{.fragment}
::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|1-4|5|6-14|6|7-9|10-12"
gsoep_ex2 %>%
  group_by(marital) %>%
  data_grid(age= seq_range(age, n = 101)) %>%
  ungroup() %>%
  augment(m2, newdata = ., se_fit = T) %>%
  ggplot(aes(x = age*10, fill = ordered(marital), color = ordered(marital))) +
    stat_lineribbon(
      aes(ydist = dist_student_t(df = df.residual(m2), mu = .fitted, sigma = .se.fit)),
      alpha = 1/4) + 
    scale_fill_brewer(palette = "Set2") +
    scale_color_brewer(palette = "Dark2") +
    labs(x = "Age (Years)", y = "Predicted Self-Rated Health"
         , fill = "Marital Status", color = "Marital Status") + 
    my_theme()
```

:::
:::{.column}

```{r, echo = F}
gsoep_ex2 %>%
  group_by(marital) %>%
  data_grid(age= seq_range(age, n = 101)) %>%
  ungroup() %>%
  augment(m2, newdata = ., se_fit = T) %>%
  ggplot(aes(x = age*10, fill = ordered(marital), color = ordered(marital))) +
    stat_lineribbon(
      aes(ydist = dist_student_t(df = df.residual(m2), mu = .fitted, sigma = .se.fit)),
      alpha = 1/4) + 
    scale_fill_brewer(palette = "Set2") +
    scale_color_brewer(palette = "Dark2") +
    labs(x = "Age (Years)", y = "Predicted Self-Rated Health"
         , fill = "Marital Status", color = "Marital Status") + 
    my_theme()
```

:::
::::
::::

## Simple Slopes  {.smaller}

* I promised I wouldn't go Bayes, but I never promised I wouldn't bootstrap!  
* Knowing how to get bootstrapped confidence and/or prediction intervals is important, especially if you work with any sort of multilevel / hierarchical models  
* Getting bootstrapped interval estimates is easy to get point estimates, but it's a little harder if we want to get it around prediction lines
  + (i.e. there's no great built in funcitons in `R` that get it for you, in my opinion)
  
## Simple Slopes  {.smaller}

But first, let's get some longitudinal data that let's us look at the interaction between marital status and changes in self-rated health within a person as they age:

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|2-4|5-7|8-10|11|12|13|1,16"
set.seed(5)
gsoep_ex3 <- gsoep %>%
  select(SID, age, marital, gender, SRhealth) %>%
  filter(marital %in% c(1,4)) %>%
  group_by(SID) %>%
  mutate(marital = min(marital, na.rm = T)) %>%
  ungroup() %>%
  mutate(marital = factor(
    marital
    , c(1,4)
    , c("Married", "Never Married")
    ), age = age/10
    , gender = factor(gender, c(1,2), c("Male", "Female"))) %>%
  drop_na()

gsoep_ex3 <- gsoep_ex3 %>%
  filter(SID %in% sample(unique(gsoep_ex3$SID), 2000))
gsoep_ex3
```

:::
:::{.column}

```{r, echo = F}
set.seed(5)
gsoep_ex3 <- gsoep %>%
  select(SID, age, marital, gender, SRhealth) %>%
  filter(marital %in% c(1,4)) %>%
  group_by(SID) %>%
  mutate(marital = min(marital, na.rm = T)) %>%
  ungroup() %>%
  mutate(marital = factor(
    marital
    , c(1,4)
    , c("Married", "Never Married")
    ), age = age/10
    , gender = factor(gender, c(1,2), c("Male", "Female"))) %>%
  drop_na()

gsoep_ex3 <- gsoep_ex3 %>%
  filter(SID %in% sample(unique(gsoep_ex3$SID), 2000))
gsoep_ex3
```

:::
::::

## Simple Slopes  

The critical term is the interaction between the two: 

```{r}
m3 <- lmer(SRhealth ~ age + marital + age:marital + (age | SID), data = gsoep_ex3)
tidy(m3)
```

Changes in health differ across marital groups

## Simple Slopes  {.smaller}

* But how? 
  + Interactions can often be tricky to unpack by point estimates alone
  + So we may want to plot separate trajectories for married and unmarried people
  
## Simple Slopes  {.smaller}

::::{.columns}
:::{.column}

```{r}
#| code-line-numbers: "|1-13|3|4|5-9|10-12|15-25|16-20|22-26"
predIntlme4 <- function(m, mod_frame, ref){
  ## get bootstrapped estimates
  b <- bootMer(
    m
    , FUN = function(x) lme4:::predict.merMod(
      x
      , newdata = mod_frame
      , re.form = ref
      )
    , nsim = 100 # do not use 100 in practice, please
    , parallel = "multicore"
    , ncpus = 16
    )
  
  ## get long form bootstrapped draws
  b_df <- bind_cols(
    mod_frame
    , t(b$t) %>%
    data.frame()
  ) %>%
    pivot_longer(
       cols = c(-age, -marital)
      , names_to = "boot"
      , values_to = "pred"
    )
  return(list(boot = b, b_df = b_df))
}

```

:::
:::{.column}

```{r}
#| code-line-numbers: "|1-7|2-5|6|9-11"
pred_fx_fun <- function(m){
  mod_frame <- crossing(
    age = seq(min(m@frame$age), max(m@frame$age), .1)
    , marital = levels(m@frame$marital)
  )
  boot <- predIntlme4(m = m, mod_frame = mod_frame, ref = NA)
}

boot3 <- pred_fx_fun(m3)
b_df3 <- boot3$b_df
b3 <- boot3$boot
```

:::
::::

## Simple Slopes  {.smaller}

```{r}
b_df3
```


## `geom_line()` {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|1|2|3-6"
b_df3 %>%
  ggplot(aes(x = age, y = pred)) + 
    geom_line(
      aes(color = marital, group = interaction(marital, boot))
      , alpha = .2, size = .25
      ) + 
    my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  ggplot(aes(x = age, y = pred)) + 
    geom_line(
      aes(color = marital, group = interaction(marital, boot))
      , alpha = .2, size = .25
      ) + 
    my_theme()
```

:::
::::



## `geom_lineribbon()`: summarized  {.smaller}

```{r}
b_df3 %>% 
  group_by(marital, age) %>%
  median_qi(pred)
```


## `geom_lineribbon()`: summarized  {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|4-9|10-14|15"
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(
    x = age
    , y = pred
    , ymin = .lower
    , ymax = .upper
    )) +
  geom_lineribbon(
    aes(fill = marital)
    , size = .9
    , alpha = .8
    ) + 
  scale_fill_brewer(palette = "Set2") +
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred, ymin = .lower, ymax = .upper)) +
  geom_lineribbon(aes(fill = marital), size = .9) + 
  scale_fill_brewer(palette = "Set2") +
  my_theme()
```

:::
::::

## `geom_lineribbon()` bands: summarized   {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "3,12"
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred, .width = c(.50, .80, .95)) %>%
  ggplot(aes(
    x = age
    , y = pred
    , ymin = .lower
    , ymax = .upper
    )) +
  geom_lineribbon(size = .9) + 
  scale_fill_brewer() +
  facet_grid(~marital) + 
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred, .width = c(.50, .80, .95)) %>%
  ggplot(aes(x = age, y = pred, ymin = .lower, ymax = .upper)) +
  geom_lineribbon(size = .9) + 
  scale_fill_brewer() +
  facet_grid(~marital) + 
  my_theme()
```

:::
::::

## `stat_lineribbon()` bands: samples {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "|1|2-5|6"
b_df3 %>%
  ggplot(aes(
    x = age
    , y = pred
    , fill = marital
    )) + 
  stat_lineribbon(alpha = .25) + 
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  ggplot(aes(x = age, y = pred, fill = marital)) + 
  stat_lineribbon(alpha = .25) + 
  my_theme()
```

:::
::::

## `stat_lineribbon()` bands: samples {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "7-9"
b_df3 %>%
  ggplot(aes(
    x = age
    , y = pred
    , fill = marital
    )) + 
  stat_lineribbon(
    aes(fill_ramp = stat(level))
    ) +
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  ggplot(aes(x = age, y = pred, fill = marital)) + 
  stat_lineribbon(aes(fill_ramp = stat(level))) +
  my_theme()
```

:::
::::


## `geom_lineribbon()` gradient: samples  {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "7-11"
b_df3 %>%
  ggplot(aes(
    x = age
    , y = pred
    , fill = marital
    )) + 
  stat_lineribbon(
    alpha = .25
    , .width = ppoints(25)
    ) + 
  scale_fill_brewer(palette = "Set2") +
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  ggplot(aes(x = age, y = pred, fill = marital)) + 
  stat_lineribbon(alpha = .25, .width = ppoints(25)) + 
  scale_fill_brewer(palette = "Set2") +
  my_theme()
```

:::
::::

## `geom_lineribbon()` gradient: samples  {.smaller}

::::{.columns}
:::{.column}

```{r, eval = F, fig.dim=c(6,6)}
#| code-line-numbers: "|4|5-8|9-10|1,11-18"
ms <- b_df3 %>% filter(age == max(age)) %>% group_by(marital) %>% summarize(m = mean(pred))

b_df3 %>%
  ggplot(aes(x = age*10, y = pred, fill = marital, fill_ramp = stat(.width))) + 
  stat_lineribbon(
    alpha = .25
    , .width = ppoints(25)
    ) +
  scale_x_continuous(limits = c(15,100), breaks = seq(15,90,15)) + 
  scale_fill_manual(values = c("grey", "darkorange")) + 
  annotate(
    "text", label = "Married", x = max(b_df3$age)*10+1
    , y = ms$m[1], hjust = 0
    ) + 
  annotate(
    "text", label = "Never\nMarried", x = max(b_df3$age)*10+1
    , y = ms$m[2], hjust = 0
    ) + 
  labs(
    x = "Age (Years)"
    , y = "Predicted Self Rated Health\n(Bootstrapped Interval Estimates)"
    , fill = NULL
    , title = "Self-Rated Health Declines More Rapidly\nfor Unmarried People"
    ) + 
  guides(fill = "none") + 
  my_theme()
```

:::
:::{.column}

```{r, echo = F}
ms <- b_df3 %>% filter(age == max(age)) %>% group_by(marital) %>% summarize(m = mean(pred))

b_df3 %>%
  ggplot(aes(x = age*10, y = pred, fill = marital, fill_ramp = stat(.width))) + 
  stat_lineribbon(alpha = .25, .width = ppoints(25)) +
  scale_x_continuous(limits = c(15,100), breaks = seq(15,90,15)) + 
  scale_fill_manual(values = c("grey", "darkorange")) + 
  annotate("text", label = "Married", x = max(b_df3$age)*10+1, y = ms$m[1], hjust = 0) + 
  annotate("text", label = "Never\nMarried", x = max(b_df3$age)*10+1, y = ms$m[2], hjust = 0) + 
  labs(
    x = "Age (Years)"
    , y = "Predicted Self Rated Health\n(Bootstrapped Interval Estimates)"
    , fill = NULL
    , title = "Self-Rated Health Declines More Rapidly for Unmarried People"
    ) + 
  guides(fill = "none") + 
  my_theme()
```

:::
::::

# Animated Uncertainty  

## Ensemble Displays  {.smaller}

* Ensemble displays are an alternative to putting hard boundaries around an interval estimate
* Remember that hard boundaries make people interpret categorical differences even when the underlying distribution is continuous
* We've already seen this: 

::::{.fragment}

```{r, echo = F, out.width="60%"}
b_df3 %>%
  ggplot(aes(x = age, y = pred)) + 
    geom_line(
      aes(color = marital, group = interaction(marital, boot))
      , alpha = .2, size = .5
      ) + 
    my_theme()
```

::::

## Ensemble Displays  
* But the challenge with visualizing uncertainty is between inference and understanding 
* We need to leverage a knowledge of perception and cognitive processes to help us leverage strengths and overcome weaknesses
* Animating visualizations can help us nudge people to process was they see and update their uncertainty estimates over time  
* We'll use the `gganimate` package to do this

## Ensemble Displays  {.smaller}

Here's a quick example:  

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    geom_line(
      data = b_df3
      , aes(group = interaction(marital, boot))
      , size = 1
      ) +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none") + 
    transition_states(boot, 1, 1)
```

## Ensemble Displays  {.smaller}

Let's break this down: 

```{r}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) 
```

## Ensemble Displays  {.smaller}

Let's break this down: 
First, we'll plot just the ribbons across the full sample based on the bootstrapped predictions

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "5-8,10"
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none")
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none")
```

:::
::::


## Ensemble Displays  {.smaller}

Let's break this down: 
Next we'll add a line for each bootstrapped sample. This doesn't look great here.  

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "10-14"
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    geom_line(
      data = b_df3
      , aes(group = interaction(marital, boot))
      , size = 1
      ) +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none")
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    geom_line(
      data = b_df3
      , aes(group = interaction(marital, boot))
      , size = 1
      ) +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none")
```

:::
::::

## Ensemble Displays  {.smaller}

Let's break this down: 
But when we use the `transition_states()` function across the bootstraped samples, we can get a better sense about where possible regression lines fall:  

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "18"
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    geom_line(
      data = b_df3
      , aes(group = interaction(marital, boot))
      , size = 1
      ) +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none") + 
    transition_states(boot, 1, 1)
```

:::
:::{.column}

```{r, echo = F}
b_df3 %>%
  group_by(marital, age) %>%
  median_qi(pred) %>%
  ggplot(aes(x = age, y = pred)) +
    geom_ribbon(
      aes(fill = marital, ymin = .lower, ymax = .upper)
      , size = .9, alpha = .5
      ) + 
    scale_fill_brewer(palette = "Set2") +
    geom_line(
      data = b_df3
      , aes(group = interaction(marital, boot))
      , size = 1
      ) +
    facet_grid(~marital) + 
    my_theme() + 
    theme(legend.position = "none") + 
    transition_states(boot, 1, 1)
```

:::
::::

## Hypothetical Outcome Plots (HOPs)  

* Similarly, hypothetical outcome plots let us see plausible mean estimates among raw data
* Here's self-rated health (1-5) across married and unmarried individuals: 

::::{.fragment}

```{r}
gsoep_ex3 %>%
  ggplot(aes(y = marital, x = SRhealth)) + 
    geom_jitter(aes(color = marital), alpha = .5) + 
    my_theme()
```

::::

## Hypothetical Outcome Plots (HOPs)  {.smaller}

* Using the `ungeviz` package, we can then use the `geom_vpline()` function to sample from the data across groups and plot the mean from different samples:  

::::{.fragment}
::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "4-8"
gsoep_ex3 %>%
  ggplot(aes(y = marital, x = SRhealth)) + 
    geom_jitter(aes(color = marital), alpha = .25) + 
    geom_vpline(
      data = sampler(25, group = marital)
      , height = 0.6
      , color = "#D55E00"
      ) +
    scale_color_manual(values = c("seagreen2", "darkorange")) + 
    my_theme()
```

:::
:::{.column}

```{r, echo = F}
gsoep_ex3 %>%
  ggplot(aes(y = marital, x = SRhealth)) + 
    geom_jitter(aes(color = marital), alpha = .25) + 
    geom_vpline(
      data = sampler(25, group = marital)
      , height = 0.6
      , color = "#D55E00"
      ) +
    scale_color_manual(values = c("seagreen2", "darkorange")) + 
    my_theme()
```

:::
::::
::::

## Hypothetical Outcome Plots (HOPs)  {.smaller}

And finally, we can animate those samples the `transition_states()` function from the `gganimate` package again:  

::::{.columns}
:::{.column}

```{r, eval = F}
#| code-line-numbers: "11"
gsoep_ex3 %>%
  ggplot(aes(y = marital, x = SRhealth)) + 
    geom_jitter(aes(color = marital), alpha = .5) + 
    geom_vpline(
      data = sampler(25, group = marital)
      , height = 0.6
      , color = "#D55E00"
      ) +
    scale_color_manual(values = c("seagreen2", "darkorange")) + 
    my_theme() + 
    transition_states(.draw, 1, 3)
```

:::
:::{.column}

```{r, echo = F}
gsoep_ex3 %>%
  ggplot(aes(y = marital, x = SRhealth)) + 
    geom_jitter(aes(color = marital), alpha = .5) + 
    geom_vpline(
      data = sampler(25, group = marital)
      , height = 0.6
      , color = "#D55E00"
      ) +
    scale_color_manual(values = c("seagreen2", "darkorange")) + 
    my_theme() + 
    transition_states(.draw, 1, 3)
```

:::
::::


<!-- * Proportions / Probability   -->
<!--   + icon array -->
<!-- * Point Estimates -->
<!--   + half-eye -->
<!--   + gradient interval -->
<!--   + quantile dotplot -->
<!--   + raincloud -->
<!-- * Animated (sometimes) -->
<!--   + hypothetical outcome plots -->
<!--   + ensemble display -->
